# 面试

#### 输入完网址按下回车，到看到网页这个过程中发生了什么

```
请求响应的流程：
  1 解析URL，解析域名生成唯一IP地址，开始搜索服务器
  2 找到服务器后，服务器接收请求被服务器进程拦截；一般而言，.net的程序会被IIS处理，java会被jBoss或者tomcat处理
  3 服务器处理请求，如果静态文件的话直接返回，若是.net或者java等动态脚本会经过服务器编译，执行其中的服务器端代码
  4 若是服务器端具有数据库操作的话，这里还需要与DB建立连接，操作数据库
  5 服务器处理结束后，生成最终的静态HTML字符串返回，开始向请求者（客户端）返回请求字符串，一次返回量过大就会分批次，这是一个优化点
  6 服务器响应到达浏览器，浏览器开始处理请求，进入浏览器解析流程
响应之后：
  浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSS Rule Tree，而javascript又可以根据DOM API操作DOM。
```

#### http 工作原理

客户机与服务器建立连接后，发送一个请求给服务器，请求格式为：统一资源标识符、协议版本号。服务器收到请求的信息包括请求行，请求头，请求体。服务器接收到请求后，给予相应的响应信息，格式为一个状态行包括响应行，响应头，响应体。

在 internet 上，http 通讯通常发生在 TCP/IP 连接之上。缺省端口是 TCP 的 80 端口。

基于 HTTP 协议的客户/服务器模式的信息交换过程，分为四个过程：建立连接、发送请求信息、发送响应信息、关闭连接。

服务器可能同时接受多个请求，这时就会产生多个 sessoin，每个 session 分别处理各自的请求。

**工作过程**

```
(1) 地址解析
 例如客户端浏览器请求这个页面：http://localhost.com:8080/index.html
 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：
 协议名：http
 主机名：localhost.com
 端口：8080
 对象路径：/index.html
(2)封装HTTP请求数据包
(3)封装成TCP包，建立TCP连接（TCP的三次握手）
(4)客户机发送请求命令
(5)服务器响应
(6)服务器关闭TCP连接
```

#### http 常用字段

##### 常用标准请求头字段

```
Accept 设置接受的内容类型
Accept-Charset 设置接受的字符编码
Accept-Encoding 设置接受的编码格式
Cache-Control 设置请求响应链上所有的缓存机制必须遵守的指令
If-Match 设置客户端的ETag
If-Modified-Since 设置更新时间
Authorization 设置HTTP身份验证的凭证
Content-Type 设置请求体的MIME类型（适用POST和PUT请求）
Cookie 设置服务器使用Set-Cookie发送的http cookie
Host 设置服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略
Referer 设置前一个页面的地址，并且前一个页面中的连接指向当前请求
User-Agent 用户代理的字符串值
```

##### 常用标准响应头字段

```
Access-Control-Allow-Origin 指定哪些站点可以参与跨站资源共享
Status 设置HTTP响应状态
Server 服务器名称
Set-Cookie 设置HTTP Cookie
Expires 设置响应体的过期时间
Content-Type 设置响应体的MIME类型
ETag 特定版本资源的标识符，通常是消息摘要
Last-Modified 设置请求对象最后一次的修改日期
```

##### 常见状态码

```
200 （成功） 服务器已成功处理了请求
301 （永久移动） 请求的网页已永久移动到新位置
302 （临时移动）重定向
304 （未修改） 自从上次请求后，请求的网页未修改过
305 （使用代理） 请求者只能使用代理访问请求的网页
400 （错误请求） 服务器不理解请求的语法
401 （未授权） 请求要求身份验证
403 （禁止） 服务器拒绝请求
404 （未找到） 服务器找不到请求的网页
500 （服务器内部错误） 服务器遇到错误，无法完成请求
501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应
503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）
504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求
505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本
```

#### TCP

##### 三次握手

    所谓三次握手就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。
    
    第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
    
    第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
    
    第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

**为什么需要三次握手，两次不可以吗？或者四次、五次可以吗？**

```
第三次握手是为了防止：如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，但问题是：服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销。
```

##### 四次挥手

```
第一次挥手: 客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。

第二次挥手: 服务器收到这个FIN，它发送一个ACK，确认ack为收到的序号加一。

第三次挥手: 关闭服务器到客户端的连接，发送一个FIN给客户端。

第四次挥手: 客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
```

**为什么是四次挥手，而不是三次或是五次、六次？**

```
（1）为了保证客户端发送的最后一个ACK报文段能够到达服务器。即最后一个确认报文可能丢失，服务器会超时重传，然后服务器发送FIN请求关闭连接，客户端发送ACK确认。一个来回是两个报文生命周期。
如果没有等待时间，发送完确认报文段就立即释放连接的话，服务器就无法重传，因此也就收不到确认，就无法按步骤进入CLOSE状态，即必须收到确认才能close。

（2）防止已经失效的连接请求报文出现在连接中。经过2MSL，在这个连续持续的时间内，产生的所有报文段就可以都从网络消失。
```

#### TCP和UDP的比较

|              | UDP                                        | TCP                                    |
| :----------- | :----------------------------------------- | -------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |
| 传输方式     | 面向报文                                   | 面向字节流                             |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

- TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。
- 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为
- 对数据准确性要求高，速度可以相对较慢的，可以选用TCP



#### 常见 css 兼容

```
1. 不同浏览器的标签默认的外补丁和内补丁不同.
解决方案：*{margin:0;padding:0;}

2. IE6双边距bug.
解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性

3. IE6标签最小高度设置min-height不兼容.
解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}

4. 透明度的兼容css设置.
解决方案：使用IE6当中的滤镜filter替代掉，如：opacity:0.6;filter:alpha(opacity=60)。

5. img外部有a标签,IE6-IE9中img外面会出现border.
解决方案：设置img边框border:0;

6. IE6空div默认行高.
解决方案：设置其高度为0，并设置overflow:hidden

7. input聚焦框颜色与样式不同.
解决方案：使用outline：none，清除默认样式之后再统一设置

8. 条件注释法（一般使用在IE6-IE9）
如  <!--[if IE 6]>
     这段文字只在IE6浏览器显示
    <![endif]-->

9. 属性前缀法
如 #selector{
      -color: red;    　　 /* 减号和下划线是IE6专有的hack */
      color：blue\9;   　　/* \9 IE6-IE10都生效 */
      color: pink\0;  　　 /* \0 IE8-IE11生效 */
      color: green\9\0;　　/* \9\0 IE9和IE10生效 */
      *color: yellow;　　  /* [.*+<>] IE6-IE7生效 */
   }

10. 选择器前缀法
如 *+html selector{color:blue;} 　　　/* *+html前缀只支持IE7 */

不管是什么方法，书写的顺序都是firefox的写在前面，IE7的写在中间，IE6的写在最后面
```

#### 常见 js 兼容

```
1. window.event.
解决方案:  e = e || window.event

2. IE下,e对象有x,y属性,但是没有pageX,pageY属性;Firefox下,e对象有pageX,pageY属性,但是没有x,y属性.
解决方案:  X = e.x || e.pageX

3. IE下,e对象有srcElement属性,但是没有target属性;Firefox下,e对象有target属性,但是没有srcElement属性.
解决方案:  target = e.target || e.srcElement

4. 阻止事件默认行为.
解决方案: if (isIE) {
            e.returnValue = false;
         } else {
            e.preventDefault();
         }

5. 停止事件冒泡或捕获.
解决方案: if (isIE) {
            e.cancelBubble = true;
         } else {
            e.stopPropagation();
         }

6. 绑定事件.
解决方案： addHandler: function(element, type, handler) {
            if (element.addEventListener)
              element.addEventListener(type, handler, false)
            else if (element.attachEvent) element.attachEvent('on' + type, handler)
            else element['on' + type] = handler
          }

7. 获取滚动条距离.
解决方案： var scrollTop= document.documentElement.scrollTop || document.body.scrollTop

8. 获取行外样式.
解决方案： funtion getStyle(obj,name){
             if(obj.currentStyle){
                return obj.currentStyle[name];
             }else{
                return getComputedStyle(obj,false)[name];
             }
          }
```

#### Sass 与 Less 区别

```
1. 编译环境
   Sass需要安装Ruby，属于服务端处理，然而Less是需要引入官网提供和的less.js，属于客户端处理

2. 变量声明
   Sass/Scss 使用的是$,而Less使用的是@

3. 输出格式
   Less无输出格式，Sass可以使用特定的输出格式
   nested：嵌套缩进的css代码
   expanded：展开的多行css代码
   compact：简洁格式的css代码
   compressed：压缩后的css代码

4. 混合不同 Mixins
    sass样式中声明Mixins时需要使用“@mixin”，然后后面紧跟Mixins的名，他也可以定义参数，同时可以给这个参数设置一个默认值，但参数名是使用“$”符号开始，而且和参数值之间需要使用冒号（：）分开。
    使用时用@include demo()

    less样式中声明更像CSS定义样式，在less可以将Mixins看成是一个类选择器，当然 Mixins也可以设置参数，并给参数设置默认值。不过设置参数的变量名是使用“@”开头，同样参数和默认参数值之间需要使用冒号（：）分 隔开。
    使用时用.demo()


5. 继承
   sass: @extend .demo
   less: .demo

6. 其他
   Sass支持条件语句，可以使用@if{}@else{},@for{}循环等等。而Less不支持。
```

#### vue 在 app 首次加载缓慢的解决办法

```
1.路由懒加载；
2.组件异步加载；
3.图片懒加载；
4.使用externals；
5.cdn加速。
```

#### 简单实现深拷贝

```javascript
function deepClone(initalObj, target) {
  var obj = target || {}
  for (var i in initalObj) {
    var prop = initalObj[i] // 避免相互引用对象导致死循环
    if (prop === obj) continue
    if (typeof prop === 'object') {
      obj[i] = prop.constructor === Array ? [] : {}
      arguments.callee(prop, obj[i])
    } else {
      obj[i] = prop
    }
  }
  return obj
}
```

#### 严格模式

##### **目的**

```　　- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
1 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
2 消除代码运行的一些不安全之处，保证代码运行的安全；
3 提高编译器效率，增加运行速度；
4 为未来新版本的Javascript做好铺垫。
```

##### **语法和行为改变**

1. 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。

2. 静态绑定

   ```
   （1）禁止使用with语句
   （2）创设eval作用域
   　"use strict";
   　　var x = 2;
   　　console.info(eval("var x = 5; x")); // 5
   　　console.info(x); // 2
   ```

3. 增强的安全措施

   ```
   （1）禁止this关键字指向全局对象
   （2）禁止在函数内部遍历调用栈
   　　function f1(){
   　　　　"use strict";
   　　　　f1.caller; // 报错
   　　　　f1.arguments; // 报错
   　　}
   　　f1();
   ```

4. 禁止删除变量

   ```
   严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。
   ```

5. 显式报错

   ```
   (1)正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。
   (2)严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。
   (3)严格模式下，对禁止扩展的对象添加新属性，会报错。
   　"use strict";
   　var o = {};
   　Object.preventExtensions(o);
   　o.v = 1; // 报错
   (4)严格模式下，删除一个不可删除的属性，会报错。
   ```

6. 重名错误

   ```
   (1)对象不能有重名的属性
      正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。
   (2)函数不能有重名的参数
      正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。
   ```

7. 禁止八进制表示法

   ```
   正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。
   ```

8. arguments 对象的限制

```
(1)不允许对arguments赋值
　　"use strict";
　　arguments++; // 语法错误
　　var obj = { set p(arguments) { } }; // 语法错误
　　try { } catch (arguments) { } // 语法错误
　　function arguments() { } // 语法错误
　　var f = new Function("arguments", "'use strict'; return 17;"); // 语法错误
　　
(2)arguments不再追踪参数的变化
　　function f(a) {
　　　　a = 2;
　　　　return [a, arguments[0]];
　　}
　　f(1); // 正常模式为[2,2]

　　function f(a) {
　　　　"use strict";
　　　　a = 2;
　　　　return [a, arguments[0]];
　　}
　　f(1); // 严格模式为[2,1]
　
 (3)禁止使用arguments.callee
```

9. 函数必须声明在顶层

   ```
   不允许在非函数的代码块内声明函数
   　　"use strict";
   　　if (true) {
   　　　　function f() { } // 语法错误
   　　}
   　　for (var i = 0; i < 5; i++) {
   　　　　function f2() { } // 语法错误
   　　}
   ```

#### 回流与重绘

**什么是回流(重排 reflow)？**

回流（重排 reflow）：对DOM树进行渲染，只要修改DOM或修改元素的形状大小，就会触发reflow，reflow的时候，浏览器会使已渲染好受到影响的部分失效，并重新构造这部分，完成reflow后，浏览器会重新绘制受影响的部分到屏幕中

**什么是重绘(repaint)？**

重绘(repaint)：当我们对DOM的修改导致的样式变化，但未影响几何属性时，浏览器不需要重新计算元素的几何属性，直接可以为该元素绘制新的样式，跳过了回流环节，这个过程就叫重绘。

**回流必定会发生重绘，重绘不一定发生回流**

**如何减少回流、重绘？**

减少回流、重绘就是减少对DOM的操作

1.直接改变className，如果动态改变样式，则使用cssText（减少设置多项内联样式）

2.让要操作的元素进行“离线处理”，处理完后一起更新

- 当使用DocumentFragment进行缓存操作，引发一次回流和重绘
- 使用display:none 技术，只引发两次回流和重绘
- 使用cloneNode(true or false)和replaceChild技术，引发一次回流和重绘

3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存

4.让元素脱离动画流，减少render 树的规模

5.牺牲平滑度换取速度

6.避免使用table布局

7.IE中避免使用javascript表达式